<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Algorithm Trainer - Dynamic</title>
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<link
			rel="stylesheet"
			href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
			crossorigin="anonymous"
		/>
		<link
			href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600;700&display=swap"
			rel="stylesheet"
		/>
		<style>
			html,
			body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				font-family: "Open Sans", sans-serif;
				overflow: hidden;
				background: #000;
			}
			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}
			.ui {
				position: absolute;
				inset: 0;
				pointer-events: none;
				color: white;
			}
			.header {
				position: absolute;
				left: 50%;
				top: 6%;
				transform: translate(-50%, -50%);
				text-align: center;
				text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
			}
			.header h1 {
				margin: 0;
				font-size: 32px;
			}
			.header p {
				margin: 6px 0 0;
				font-size: 16px;
				opacity: 0.8;
			}
			.controls {
				position: absolute;
				right: 4%;
				top: 6%;
				display: flex;
				gap: 12px;
				align-items: center;
				pointer-events: auto;
			}
			.control-button {
				background: rgba(0, 0, 0, 0.5);
				border: 1px solid rgba(255, 255, 255, 0.2);
				color: white;
				padding: 10px 14px;
				border-radius: 8px;
				cursor: pointer;
				font-size: 16px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				gap: 6px;
			}
			.control-button:disabled {
				opacity: 0.5;
				cursor: not-allowed;
			}
			.arrowBack {
				position: absolute;
				left: 5%;
				top: 6%;
				transform: translate(-50%, -50%);
				font-size: 24px;
				pointer-events: auto;
			}
			.arrowBack a {
				color: white;
				text-decoration: none;
			}
			.algorithm-display {
				position: absolute;
				left: 50%;
				bottom: 8%;
				transform: translate(-50%, 50%);
				font-size: 36px;
				font-weight: 600;
				text-align: center;
				pointer-events: none;
				letter-spacing: 1px;
				background: rgba(0, 0, 0, 0.55);
				padding: 12px 18px;
				border-radius: 14px;
				border: 1px solid rgba(255, 255, 255, 0.15);
				box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
			}
			.algorithm-display span {
				display: inline-block;
				padding: 0 4px;
				transition: color 0.3s ease;
			}
			.algorithm-display span.active {
				color: #f0d804;
			}
		</style>
	</head>
	<body>
		<canvas id="renderCanvas"></canvas>

		<div class="ui">
			<div class="arrowBack">
				<a href="../index.html#algSection"><i class="fas fa-caret-left"></i> Back</a>
			</div>
			<div class="header">
				<h1 id="algTitle">Algorithm demo</h1>
				<p>Drag to orbit the cube while the moves play.</p>
			</div>
			<div class="controls">
				<button class="control-button" id="stepBack" title="Step back (←)">
					<i class="fas fa-backward"></i>
				</button>
				<button class="control-button" id="togglePlayback" title="Pause/Play (Space)">
					<i class="fas fa-play"></i>
				</button>
				<button class="control-button" id="stepForward" title="Step forward (→)">
					<i class="fas fa-forward"></i>
				</button>
				<button class="control-button" id="restartPlayback" title="Reset">
					<i class="fas fa-history"></i>
				</button>
			</div>
			<div class="algorithm-display" id="algorithmDisplay"></div>
		</div>

		<script>
			const canvas = document.getElementById("renderCanvas");
			const engine = new BABYLON.Engine(canvas, true);
			const algorithmDisplay = document.getElementById("algorithmDisplay");
			const togglePlayback = document.getElementById("togglePlayback");
			const restartPlayback = document.getElementById("restartPlayback");
			const stepBack = document.getElementById("stepBack");
			const stepForward = document.getElementById("stepForward");
			const algTitle = document.getElementById("algTitle");

			let scene;
			let camera;
			let pivot;
			let holder;
			let cubies = [];
			let moveQueue = [];
			let isPaused = false;
			let isAnimating = false;
			let isScrambled = false;
			let isPlayingForward = false;
			let isManualMode = false;
			let currentSpeed = 60;
			let activeRunId = 0;
			let currentMoveIndex = 0;

			const DEFAULT_ALGORITHM = "R U R' U R U2 R'";

			const initScene = () => {
				scene = new BABYLON.Scene(engine);
				camera = new BABYLON.ArcRotateCamera(
					"camera",
					0,
					0,
					10,
					BABYLON.Vector3.Zero(),
					scene
				);
				camera.setPosition(new BABYLON.Vector3(5, 5, -5));
				camera.attachControl(canvas, true);
				camera.lowerRadiusLimit = 10;
				camera.upperRadiusLimit = 10;

				const light = new BABYLON.HemisphericLight(
					"light",
					new BABYLON.Vector3(0, 1, 0),
					scene
				);
				light.intensity = 2;
				light.groundColor = new BABYLON.Color3(1, 1, 1);

				const fillLight = new BABYLON.HemisphericLight(
					"fillLight",
					new BABYLON.Vector3(0, -1, 0),
					scene
				);
				fillLight.intensity = 0.8;
				scene.ambientColor = new BABYLON.Color3(0.9, 0.9, 0.9);

				const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 100.0 }, scene);
				const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMaterial", scene);
				skyboxMaterial.backFaceCulling = false;
				skyboxMaterial.disableLighting = true;
				skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
					"../textures/skybox/skybox",
					scene
				);
				skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
				skybox.material = skyboxMaterial;

				holder = new BABYLON.TransformNode("holder", scene);
				pivot = new BABYLON.TransformNode("pivot", scene);
				cubies = createCubies(scene);
			};

			const createCubies = (scene) => {
				const faceColors = [
					BABYLON.Color4.FromHexString("#0066FFFF"),
					BABYLON.Color4.FromHexString("#33CC00FF"),
					BABYLON.Color4.FromHexString("#FF9900FF"),
					BABYLON.Color4.FromHexString("#FF0000FF"),
					BABYLON.Color4.FromHexString("#FFFF66FF"),
					BABYLON.Color4.FromHexString("#FFFFFFFF"),
				];
				const cubes = [];
				for (let x = -1; x <= 1; x++) {
					for (let y = -1; y <= 1; y++) {
						for (let z = -1; z <= 1; z++) {
							const cubie = BABYLON.MeshBuilder.CreateBox(
								"cubie",
								{
									faceColors: [...faceColors],
									size: 0.98,
								},
								scene
							);
							cubie.position = new BABYLON.Vector3(x, y, z);
							cubie.metadata = { initialPosition: cubie.position.clone() };
							cubie.setParent(holder);
							cubes.push(cubie);
						}
					}
				}
				return cubes;
			};

			const resetCube = () => {
				cubies.forEach((cubie) => {
					cubie.setParent(holder);
					const { initialPosition } = cubie.metadata;
					cubie.position.copyFrom(initialPosition);
					cubie.rotation = BABYLON.Vector3.Zero();
				});
				pivot.rotation = BABYLON.Vector3.Zero();
			};

			const parseAlgorithm = (algorithm) => {
				const tokens = algorithm
					.split(/\s+/)
					.map((token) => token.trim())
					.filter(Boolean);

				return tokens.map((token) => {
					const match = token.match(/^([RULDFB])([2]?)(['`]?)$/i);
					if (!match) {
						throw new Error(`Invalid move: ${token}`);
					}
					const face = match[1].toUpperCase();
					const isDouble = match[2] === "2";
					const isPrime = match[3] === "'" || match[3] === "`";
					return { face, isDouble, isPrime, raw: token };
				});
			};

			const moveToRotation = (move) => {
				const faceMap = {
					R: { axis: "x", layer: 1, invert: false },
					L: { axis: "x", layer: -1, invert: true },
					U: { axis: "y", layer: 1, invert: false },
					D: { axis: "y", layer: -1, invert: true },
					F: { axis: "z", layer: 1, invert: false },
					B: { axis: "z", layer: -1, invert: true },
				};

				const { axis, layer, invert } = faceMap[move.face];
				let direction = move.isPrime ? -1 : 1;
				if (invert) direction *= -1;
				const angle = move.isDouble
					? Math.PI * direction
					: (Math.PI / 2) * direction;
				return { axis, layer, angle };
			};

			const rotateLayer = (axis, layer, angle) => {
				return new Promise((resolve) => {
					const cubiesToRotate = cubies.filter(
						(cubie) => Math.round(cubie.position[axis]) === layer
					);

					cubiesToRotate.forEach((cubie) => cubie.setParent(pivot));
					pivot.rotation = BABYLON.Vector3.Zero();

					const snapAngle = (value) => {
						const quarterTurn = Math.PI / 2;
						return Math.round(value / quarterTurn) * quarterTurn;
					};

					scene.stopAnimation(pivot);
					const animation = new BABYLON.Animation(
						"rotate",
						`rotation.${axis}`,
						currentSpeed,
						BABYLON.Animation.ANIMATIONTYPE_FLOAT,
						BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
					);
					animation.setKeys([
						{ frame: 0, value: 0 },
						{ frame: 30, value: angle },
					]);
					pivot.animations = [animation];

					const animatable = scene.beginAnimation(pivot, 0, 30, false);
					animatable.onAnimationEndObservable.addOnce(() => {
						cubiesToRotate.forEach((cubie) => {
							cubie.setParent(null);
							cubie.position.x = Math.round(cubie.position.x);
							cubie.position.y = Math.round(cubie.position.y);
							cubie.position.z = Math.round(cubie.position.z);
							cubie.rotation.x = snapAngle(cubie.rotation.x);
							cubie.rotation.y = snapAngle(cubie.rotation.y);
							cubie.rotation.z = snapAngle(cubie.rotation.z);
							cubie.setParent(holder);
						});
						pivot.rotation = BABYLON.Vector3.Zero();
						resolve();
					});
				});
			};

			const updateAlgorithmDisplay = (moves) => {
				algorithmDisplay.innerHTML = moves
					.map((move) => `<span>${move.raw}</span>`)
					.join(" ");
			};

			const setActiveMove = (index) => {
				const spans = algorithmDisplay.querySelectorAll("span");
				spans.forEach((span) => span.classList.remove("active"));
				if (spans[index]) spans[index].classList.add("active");
			};

			const playMoves = async (moves, { speed, highlight, runId }) => {
				currentSpeed = speed;
				for (let index = 0; index < moves.length; index++) {
					while (isPaused && runId === activeRunId) {
						await new Promise((resolve) => setTimeout(resolve, 100));
					}
					if (runId !== activeRunId) return;
					if (highlight) setActiveMove(index);
					const rotation = moveToRotation(moves[index]);
					await rotateLayer(rotation.axis, rotation.layer, rotation.angle);
					if (runId !== activeRunId) return;
				}
				if (highlight) setActiveMove(-1);
			};

			const invertMoves = (moves) => {
				return [...moves]
					.reverse()
					.map((move) => ({
						...move,
						isPrime: move.isDouble ? move.isPrime : !move.isPrime,
					}));
			};

			const updateToggleIcon = () => {
				const icon = togglePlayback.querySelector("i");
				const showPlay = !isPlayingForward || isPaused;
				icon.classList.toggle("fa-play", showPlay);
				icon.classList.toggle("fa-pause", !showPlay);
			};

			const updateManualControls = () => {
				togglePlayback.disabled = isManualMode;
			};

			const updateActiveFromIndex = () => {
				if (currentMoveIndex >= 0 && currentMoveIndex < moveQueue.length) {
					setActiveMove(currentMoveIndex);
				} else {
					setActiveMove(-1);
				}
			};

			const enterManualMode = () => {
				if (!isManualMode) {
					isManualMode = true;
					activeRunId += 1;
					isPaused = true;
					isAnimating = false;
					isPlayingForward = false;
					updateToggleIcon();
					updateManualControls();
				}
			};

			const scrambleCube = async () => {
				const runId = ++activeRunId;
				isAnimating = true;
				isScrambled = false;
				isPlayingForward = false;
				isPaused = false;
				isManualMode = false;
				const setupMoves = invertMoves(moveQueue);
				togglePlayback.disabled = true;
				updateToggleIcon();
				updateManualControls();
				await playMoves(setupMoves, { speed: 120, highlight: false, runId });
				if (runId !== activeRunId) return;
				isAnimating = false;
				isScrambled = true;
				currentMoveIndex = 0;
				togglePlayback.disabled = false;
				updateToggleIcon();
				updateManualControls();
				updateActiveFromIndex();
			};

			const playForward = async () => {
				if (isAnimating || !isScrambled || isManualMode) return;
				const runId = ++activeRunId;
				isAnimating = true;
				isPlayingForward = true;
				isPaused = false;
				updateToggleIcon();
				currentSpeed = 60;
				for (let index = currentMoveIndex; index < moveQueue.length; index++) {
					while (isPaused && runId === activeRunId) {
						await new Promise((resolve) => setTimeout(resolve, 100));
					}
					if (runId !== activeRunId) return;
					setActiveMove(index);
					const rotation = moveToRotation(moveQueue[index]);
					await rotateLayer(rotation.axis, rotation.layer, rotation.angle);
					if (runId !== activeRunId) return;
					currentMoveIndex = index + 1;
				}
				setActiveMove(-1);
				if (runId !== activeRunId) return;
				isAnimating = false;
				isPlayingForward = false;
				isPaused = false;
				updateToggleIcon();
			};

			const stepForwardMove = async () => {
				enterManualMode();
				if (isAnimating || !isScrambled) return;
				if (currentMoveIndex >= moveQueue.length) return;
				isAnimating = true;
				setActiveMove(currentMoveIndex);
				const rotation = moveToRotation(moveQueue[currentMoveIndex]);
				await rotateLayer(rotation.axis, rotation.layer, rotation.angle);
				currentMoveIndex += 1;
				isAnimating = false;
				updateActiveFromIndex();
			};

			const stepBackMove = async () => {
				enterManualMode();
				if (isAnimating || !isScrambled) return;
				if (currentMoveIndex <= 0) return;
				isAnimating = true;
				const previousMove = moveQueue[currentMoveIndex - 1];
				const inverseMove = {
					...previousMove,
					isPrime: previousMove.isDouble
						? previousMove.isPrime
						: !previousMove.isPrime,
				};
				setActiveMove(currentMoveIndex - 1);
				const rotation = moveToRotation(inverseMove);
				await rotateLayer(rotation.axis, rotation.layer, rotation.angle);
				currentMoveIndex -= 1;
				isAnimating = false;
				updateActiveFromIndex();
			};

			const readAlgorithmFromQuery = () => {
				const params = new URLSearchParams(window.location.search);
				const alg = params.get("alg");
				return alg ? decodeURIComponent(alg).trim() : DEFAULT_ALGORITHM;
			};

			const initializeAlgorithm = () => {
				try {
					const algorithm = readAlgorithmFromQuery();
					algTitle.textContent = `Algorithm: ${algorithm}`;
					moveQueue = parseAlgorithm(algorithm);
					updateAlgorithmDisplay(moveQueue);
					setActiveMove(-1);
					resetCube();
					scrambleCube();
				} catch (error) {
					algTitle.textContent = "Algorithm error";
					algorithmDisplay.textContent = error.message;
				}
			};

			togglePlayback.addEventListener("click", () => {
				if (!isScrambled) return;
				if (isManualMode) return;
				if (!isPlayingForward) {
					playForward();
					return;
				}
				isPaused = !isPaused;
				updateToggleIcon();
			});

			restartPlayback.addEventListener("click", () => {
				activeRunId += 1;
				isPaused = false;
				isAnimating = false;
				isPlayingForward = false;
				isScrambled = false;
				isManualMode = false;
				currentMoveIndex = 0;
				updateToggleIcon();
				updateManualControls();
				initializeAlgorithm();
			});

			stepForward.addEventListener("click", () => {
				stepForwardMove();
			});

			stepBack.addEventListener("click", () => {
				stepBackMove();
			});

			window.addEventListener("keydown", (event) => {
				if (event.key === "ArrowRight") {
					event.preventDefault();
					stepForwardMove();
				}
				if (event.key === "ArrowLeft") {
					event.preventDefault();
					stepBackMove();
				}
				if (event.key === " ") {
					event.preventDefault();
					if (isManualMode) return;
					togglePlayback.click();
				}
			});

			initScene();
			initializeAlgorithm();

			engine.runRenderLoop(() => scene.render());
			window.addEventListener("resize", () => engine.resize());
		</script>
	</body>
</html>
