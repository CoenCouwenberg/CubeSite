<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

		<title>Alg trainer Cube Coen Couwenberg</title>

		<!-- Babylon.js -->
		<script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

		<!-- Font Awesome -->
		<link
			rel="stylesheet"
			href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
			integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p"
			crossorigin="anonymous"
		/>

		<!-- fonts Open Sans-->
		<link rel="preconnect" href="https://fonts.gstatic.com" />
		<link
			href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&display=swap"
			rel="stylesheet"
		/>

		<!-- CSS bestand -->
		<link rel="stylesheet" href="assets/style.css" />
	</head>
	<body>
		<canvas id="renderCanvas"></canvas>
		<div class="section1">
			<div class="title">
				<div class="bannerTitle">
					<h1>Algorithm trainer</h1>
				</div>
				<div class="bannerSub">
					<p
						description='"3x3 Cube Solve" (https://skfb.ly/6zxJO) by Etherlyte is licensed under Creative Commons Attribution (http://creativecommons.org/licenses/by/4.0/).
					'
					>
						Click & hold to see around the cube
					</p>
				</div>
			</div>

			<div class="arrowDown">
				<a href="#algSection">
					<div class="downText">Down</div>
					<div class="icon">
						<i class="fas fa-sort-down"></i>
					</div>
				</a>
			</div>
		</div>

		<div class="section2" id="algSection">
			<div class="section2title">
				<a href="#renderCanvas">
					<i class="fas fa-caret-up"></i>
					<h2>Choose an algorithm</h2>
				</a>
			</div>
			<div class="chooseAlg">
				<div class="algorithms">
					<!-- 1 -->
					<a href="algs/alg.html?alg=R%20U%20R'%20U%20R%20U2%20R'">
						<div class="boxAlg">
							<img src="imgAlgs/1.png" alt="first alg" />
							<div class="algRight">
								<h2>R U R' U R U2 R'</h2>
								<p>
									OCLL7 - 27 - <span style="color: blue">probability = 1/54</span>
								</p>
							</div>
						</div>
					</a>
					<!-- 2 -->
					<a href="algs/alg2.html">
						<div class="boxAlg">
							<img src="imgAlgs/2.png" alt="Second alg" />
							<div class="algRight">
								<h2>R U2 R' U' R U' R'</h2>
								<p>
									OCLL7 - 26 - <span style="color: blue">probability = 1/54</span>
								</p>
							</div>
						</div>
					</a>
					<!-- 3 -->
					<a href="algs/alg3.html">
						<div class="boxAlg">
							<img src="imgAlgs/3.png" alt="third alg" />
							<div class="algRight">
								<h2>(R U R'U) (R U' R' U) (R U2 R')</h2>
								<p>
									OCLL7 - 21 -
									<span style="color: green">probability = 1/108</span>
								</p>
							</div>
						</div>
					</a>
					<!-- 4 -->
					<a href="algs/alg4.html">
					<div class="boxAlg" style="margin-right: -100px;">
						<img src="imgAlgs/4.png" alt="fourth alg" />
						<div class="algRight">
							<h2>R U2' R2 U' R2 U' R2' U2' R</h2>
							<p>OCLL2 - 22 - <span style="color: blue">probability = 1/54</span></p>
						</div>
					</div>
					</a>
					<a href="algs/algChatGPT.html">
					<div class="boxAlg">
						<img src="imgAlgs/1.png" alt="first alg" />
						<div class="algRight">
							<h2>New Version</h2>
							<p>OCLL7 - 27 - <span style="color: blue">probability = 1/54</span></p>
						</div>
					</div>
					</a>
					<div class="boxAlg">
						<img src="imgAlgs/1.png" alt="first alg" />
						<div class="algRight">
							<h2>R U R' U R U2 R'</h2>
							<p>OCLL7 - 27 - <span style="color: blue">probability = 1/54</span></p>
						</div>
					</div>
				</div>
			</div>
			<div class="ollOverview" id="ollOverview">
				<div class="section2title ollTitle">
					<h2>OLL algorithm overview</h2>
					<p>Choose any OLL case below to practice the full algorithm.</p>
				</div>
				<div class="ollTable" id="ollTable"></div>
			</div>

			<div class="help">
				<a href="help.html">
					<i class="far fa-question-circle"></i>
				</a>
			</div>
		</div>
		<div class="version-note">Version: v0.3.0</div>
		<script>
			var canvas = document.getElementById("renderCanvas");

			var engine = null;
			var scene = null;
			var sceneToRender = null;
			var createDefaultEngine = function () {
				return new BABYLON.Engine(canvas, true, {
					preserveDrawingBuffer: true,
					stencil: true,
					disableWebGL2Support: false,
				});
			};
			var delayCreateScene = function () {
				// Create a scene.
				var scene = new BABYLON.Scene(engine);
				var bannerCube;

				// Parameters: name, position, scene
				// var camera = new BABYLON.FollowCamera(
				// 	"FollowCam",
				// 	new BABYLON.Vector3(0, 10, -10),
				// 	scene
				// );
				// This creates and positions a free camera (non-mesh)
				// Parameters: name, alpha, beta, radius, target position, scene
				var camera = new BABYLON.ArcRotateCamera(
					"Camera",
					0,
					0,
					10,
					new BABYLON.Vector3(0, 0, 0),
					scene
				);
				// Positions the camera overwriting alpha, beta, radius
				camera.setPosition(new BABYLON.Vector3(0, 0, 20));
				// This attaches the camera to the canvas
				camera.attachControl(canvas, true);
				camera.wheelPrecision = 100; //Mouse wheel speed
				// camera.inputs.remove(camera.inputs.attached.mousewheel);

				// Create a default skybox with an environment.
				var hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
					"textures/environment2.dds",
					scene
				);
				var currentSkybox = scene.createDefaultSkybox(hdrTexture, true);

				// Append glTF model to scene.
				var bannerCube = BABYLON.SceneLoader.Append(
					"./",
					"scene.gltf",
					scene,
					function (scene) {
						// Create a default arc rotate camera and light.
						scene.createDefaultCameraOrLight(true, true, true);

						// The default camera looks at the back of the asset.
						// Rotate the camera by 180 degrees to the front of the asset.
						scene.activeCamera.alpha += Math.PI;
					}
				);

				// camera.rotation.x = +0.1;
				// "3x3 Cube Solve" (https://skfb.ly/6zxJO) by Etherlyte is licensed under Creative Commons Attribution (http://creativecommons.org/licenses/by/4.0/).

				return scene;
			};
			var engine;
			var scene;
			initFunction = async function () {
				var asyncEngineCreation = async function () {
					try {
						return createDefaultEngine();
					} catch (e) {
						console.log(
							"the available createEngine function failed. Creating the default engine instead"
						);
						return createDefaultEngine();
					}
				};

				engine = await asyncEngineCreation();
				if (!engine) throw "engine should not be null.";
				scene = delayCreateScene();
			};
			initFunction().then(() => {
				sceneToRender = scene;
				engine.runRenderLoop(function () {
					if (sceneToRender && sceneToRender.activeCamera) {
						sceneToRender.render();
					}
				});
			});

			// Resize
			window.addEventListener("resize", function () {
				engine.resize();
			});
		</script>
		<script>
			const ollAlgorithms = [
				{
					number: 29,
					name: "Awkward Shape",
					group: "Awkward Shape",
					algorithm: "R U R' U' R U' R' F' U' F R U R'",
				},
				{
					number: 30,
					name: "Awkward Shape",
					group: "Awkward Shape",
					algorithm: "F R' F R2 U' R' U' R U R' F2",
				},
				{
					number: 41,
					name: "Awkward Shape",
					group: "Awkward Shape",
					algorithm: "R U R' U R U2 R' F R U R' U' F'",
				},
				{
					number: 42,
					name: "Awkward Shape",
					group: "Awkward Shape",
					algorithm: "R' U' R U' R' U2 R F R U R' U' F'",
				},
				{
					number: 39,
					name: "Big Lightning Bolt",
					group: "Big Lightning Bolt",
					algorithm: "L F' L' U' L U F U' L'",
				},
				{
					number: 40,
					name: "Big Lightning Bolt",
					group: "Big Lightning Bolt",
					algorithm: "R' F R U R' U' F' U R",
				},
				{
					number: 34,
					name: "C Shape",
					group: "C Shape",
					algorithm: "R U R2 U' R' F R U R U' F'",
				},
				{
					number: 46,
					name: "C Shape",
					group: "C Shape",
					algorithm: "R' U' R' F R F' U R",
				},
				{
					number: 28,
					name: "Corners Oriented",
					group: "Corners Oriented",
					algorithm: "r U R' U' r' R U R U' R'",
				},
				{
					number: 57,
					name: "Corners Oriented",
					group: "Corners Oriented",
					algorithm: "R U R' U' M' U R U' r'",
				},
				{
					number: 21,
					name: "Cross",
					group: "Cross",
					algorithm: "R U2 R' U' R U R' U' R U' R'",
				},
				{
					number: 22,
					name: "Cross",
					group: "Cross",
					algorithm: "R U2 R2 U' R2 U' R2 U2 R",
				},
				{
					number: 23,
					name: "Cross",
					group: "Cross",
					algorithm: "R2 D' R U2 R' D R U2 R",
				},
				{
					number: 24,
					name: "Cross",
					group: "Cross",
					algorithm: "r U R' U' r' F R F'",
				},
				{
					number: 25,
					name: "Cross",
					group: "Cross",
					algorithm: "F' r U R' U' r' F R",
				},
				{
					number: 26,
					name: "Cross",
					group: "Cross",
					algorithm: "R U2 R' U' R U' R'",
				},
				{
					number: 27,
					name: "Cross",
					group: "Cross",
					algorithm: "R U R' U R U2 R'",
				},
				{
					number: 1,
					name: "Dot",
					group: "Dot",
					algorithm: "R U2 R2 F R F' U2 R' F R F'",
				},
				{
					number: 2,
					name: "Dot",
					group: "Dot",
					algorithm: "r U r' U2 r U2 R' U2 R U' r'",
				},
				{
					number: 3,
					name: "Dot",
					group: "Dot",
					algorithm: "r' R2 U R' U r U2 r' U M'",
				},
				{
					number: 4,
					name: "Dot",
					group: "Dot",
					algorithm: "M U' r U2 r' U' R U' R' M'",
				},
				{
					number: 17,
					name: "Dot",
					group: "Dot",
					algorithm: "F R' F' R2 r' U R U' R' U' M'",
				},
				{
					number: 18,
					name: "Dot",
					group: "Dot",
					algorithm: "r U R' U R U2 r2 U' R U' R' U2 r",
				},
				{
					number: 19,
					name: "Dot",
					group: "Dot",
					algorithm: "r' R U R U R' U' M' R' F R F'",
				},
				{
					number: 20,
					name: "Dot",
					group: "Dot",
					algorithm: "r U R' U' M2 U R U' R' U' M'",
				},
				{
					number: 9,
					name: "Fish Shape",
					group: "Fish Shape",
					algorithm: "R U R' U' R' F R2 U R' U' F'",
				},
				{
					number: 10,
					name: "Fish Shape",
					group: "Fish Shape",
					algorithm: "R U R' U R' F R F' R U2 R'",
				},
				{
					number: 35,
					name: "Fish Shape",
					group: "Fish Shape",
					algorithm: "R U2 R2 F R F' R U2 R'",
				},
				{
					number: 37,
					name: "Fish Shape",
					group: "Fish Shape",
					algorithm: "F R' F' R U R U' R'",
				},
				{
					number: 51,
					name: "I Shape",
					group: "I Shape",
					algorithm: "F U R U' R' U R U' R' F'",
				},
				{
					number: 52,
					name: "I Shape",
					group: "I Shape",
					algorithm: "R U R' U R U' B U' B' R'",
				},
				{
					number: 55,
					name: "I Shape",
					group: "I Shape",
					algorithm: "R' F R U R U' R2 F' R2 U' R' U R U R'",
				},
				{
					number: 56,
					name: "I Shape",
					group: "I Shape",
					algorithm: "r' U' r U' R' U R U' R' U R r' U r",
				},
				{
					number: 13,
					name: "Knight Move Shape",
					group: "Knight Move Shape",
					algorithm: "F U R U' R2 F' R U R U' R'",
				},
				{
					number: 14,
					name: "Knight Move Shape",
					group: "Knight Move Shape",
					algorithm: "R' F R U R' F' R F U' F'",
				},
				{
					number: 15,
					name: "Knight Move Shape",
					group: "Knight Move Shape",
					algorithm: "l' U' l L' U' L U l' U l",
				},
				{
					number: 16,
					name: "Knight Move Shape",
					group: "Knight Move Shape",
					algorithm: "r U r' R U R' U' r U' r'",
				},
				{
					number: 31,
					name: "P Shape",
					group: "P Shape",
					algorithm: "R' U' F U R U' R' F' R",
				},
				{
					number: 32,
					name: "P Shape",
					group: "P Shape",
					algorithm: "L U F' U' L' U L F L'",
				},
				{
					number: 43,
					name: "P Shape",
					group: "P Shape",
					algorithm: "F' U' L' U L F",
				},
				{
					number: 44,
					name: "P Shape",
					group: "P Shape",
					algorithm: "F U R U' R' F'",
				},
				{
					number: 47,
					name: "Small L Shape",
					group: "Small L Shape",
					algorithm: "R' U' R' F R F' R' F R F' U R",
				},
				{
					number: 48,
					name: "Small L Shape",
					group: "Small L Shape",
					algorithm: "F R U R' U' R U R' U' F'",
				},
				{
					number: 49,
					name: "Small L Shape",
					group: "Small L Shape",
					algorithm: "r U' r2 U r2 U r2 U' r",
				},
				{
					number: 50,
					name: "Small L Shape",
					group: "Small L Shape",
					algorithm: "r' U r2 U' r2 U' r2 U r'",
				},
				{
					number: 53,
					name: "Small L Shape",
					group: "Small L Shape",
					algorithm: "l' U2 L U L' U' L U L' U l",
				},
				{
					number: 54,
					name: "Small L Shape",
					group: "Small L Shape",
					algorithm: "r U2 R' U' R U R' U' R U' r'",
				},
				{
					number: 7,
					name: "Small Lightning Bolt",
					group: "Small Lightning Bolt",
					algorithm: "r U R' U R U2 r'",
				},
				{
					number: 8,
					name: "Small Lightning Bolt",
					group: "Small Lightning Bolt",
					algorithm: "l' U' L U' L' U2 l",
				},
				{
					number: 11,
					name: "Small Lightning Bolt",
					group: "Small Lightning Bolt",
					algorithm: "r U R' U R' F R F' R U2 r'",
				},
				{
					number: 12,
					name: "Small Lightning Bolt",
					group: "Small Lightning Bolt",
					algorithm: "M' R' U' R U' R' U2 R U' R r'",
				},
				{
					number: 5,
					name: "Square Shape",
					group: "Square Shape",
					algorithm: "l' U2 L U L' U l",
				},
				{
					number: 6,
					name: "Square Shape",
					group: "Square Shape",
					algorithm: "r U2 R' U' R U' r'",
				},
				{
					number: 33,
					name: "T Shape",
					group: "T Shape",
					algorithm: "R U R' U' R' F R F'",
				},
				{
					number: 45,
					name: "T Shape",
					group: "T Shape",
					algorithm: "F R U R' U' F'",
				},
				{
					number: 36,
					name: "W Shape",
					group: "W Shape",
					algorithm: "L' U' L U' L' U L U L F' L' F",
				},
				{
					number: 38,
					name: "W Shape",
					group: "W Shape",
					algorithm: "R U R' U R U' R' U' R' F R F'",
				},
			];

			const createSolvedCube = () => ({
				U: Array(9).fill("Y"),
				D: Array(9).fill("W"),
				F: Array(9).fill("G"),
				B: Array(9).fill("B"),
				R: Array(9).fill("R"),
				L: Array(9).fill("O"),
			});

			const rotateFaceCW = (face) => {
				const [a, b, c, d, e, f, g, h, i] = face;
				face[0] = g;
				face[1] = d;
				face[2] = a;
				face[3] = h;
				face[4] = e;
				face[5] = b;
				face[6] = i;
				face[7] = f;
				face[8] = c;
			};

			const applyBaseMove = (cube, face) => {
				switch (face) {
					case "U": {
						rotateFaceCW(cube.U);
						const temp = cube.F.slice(0, 3);
						cube.F.splice(0, 3, ...cube.R.slice(0, 3));
						cube.R.splice(0, 3, ...cube.B.slice(0, 3));
						cube.B.splice(0, 3, ...cube.L.slice(0, 3));
						cube.L.splice(0, 3, ...temp);
						break;
					}
					case "D": {
						rotateFaceCW(cube.D);
						const temp = cube.F.slice(6, 9);
						cube.F.splice(6, 3, ...cube.L.slice(6, 9));
						cube.L.splice(6, 3, ...cube.B.slice(6, 9));
						cube.B.splice(6, 3, ...cube.R.slice(6, 9));
						cube.R.splice(6, 3, ...temp);
						break;
					}
					case "R": {
						rotateFaceCW(cube.R);
						const temp = [cube.U[2], cube.U[5], cube.U[8]];
						[cube.U[2], cube.U[5], cube.U[8]] = [
							cube.F[2],
							cube.F[5],
							cube.F[8],
						];
						[cube.F[2], cube.F[5], cube.F[8]] = [
							cube.D[2],
							cube.D[5],
							cube.D[8],
						];
						[cube.D[2], cube.D[5], cube.D[8]] = [
							cube.B[6],
							cube.B[3],
							cube.B[0],
						];
						[cube.B[6], cube.B[3], cube.B[0]] = temp;
						break;
					}
					case "L": {
						rotateFaceCW(cube.L);
						const temp = [cube.U[0], cube.U[3], cube.U[6]];
						[cube.U[0], cube.U[3], cube.U[6]] = [
							cube.B[8],
							cube.B[5],
							cube.B[2],
						];
						[cube.B[8], cube.B[5], cube.B[2]] = [
							cube.D[0],
							cube.D[3],
							cube.D[6],
						];
						[cube.D[0], cube.D[3], cube.D[6]] = [
							cube.F[0],
							cube.F[3],
							cube.F[6],
						];
						[cube.F[0], cube.F[3], cube.F[6]] = temp;
						break;
					}
					case "F": {
						rotateFaceCW(cube.F);
						const temp = [cube.U[6], cube.U[7], cube.U[8]];
						[cube.U[6], cube.U[7], cube.U[8]] = [
							cube.L[8],
							cube.L[5],
							cube.L[2],
						];
						[cube.L[8], cube.L[5], cube.L[2]] = [
							cube.D[2],
							cube.D[1],
							cube.D[0],
						];
						[cube.D[2], cube.D[1], cube.D[0]] = [
							cube.R[0],
							cube.R[3],
							cube.R[6],
						];
						[cube.R[0], cube.R[3], cube.R[6]] = temp;
						break;
					}
					case "B": {
						rotateFaceCW(cube.B);
						const temp = [cube.U[0], cube.U[1], cube.U[2]];
						[cube.U[0], cube.U[1], cube.U[2]] = [
							cube.R[2],
							cube.R[5],
							cube.R[8],
						];
						[cube.R[2], cube.R[5], cube.R[8]] = [
							cube.D[8],
							cube.D[7],
							cube.D[6],
						];
						[cube.D[8], cube.D[7], cube.D[6]] = [
							cube.L[6],
							cube.L[3],
							cube.L[0],
						];
						[cube.L[6], cube.L[3], cube.L[0]] = temp;
						break;
					}
					case "M": {
						const temp = [cube.U[1], cube.U[4], cube.U[7]];
						[cube.U[1], cube.U[4], cube.U[7]] = [
							cube.B[7],
							cube.B[4],
							cube.B[1],
						];
						[cube.B[7], cube.B[4], cube.B[1]] = [
							cube.D[1],
							cube.D[4],
							cube.D[7],
						];
						[cube.D[1], cube.D[4], cube.D[7]] = [
							cube.F[1],
							cube.F[4],
							cube.F[7],
						];
						[cube.F[1], cube.F[4], cube.F[7]] = temp;
						break;
					}
					default:
						break;
				}
			};

			const applyMove = (cube, move) => {
				const times = move.isDouble ? 2 : 1;
				const direction = move.isPrime ? -1 : 1;
				for (let i = 0; i < times; i += 1) {
					if (move.face === "r") {
						if (direction === 1) {
							applyBaseMove(cube, "R");
							applyBaseMove(cube, "M");
							applyBaseMove(cube, "M");
							applyBaseMove(cube, "M");
						} else {
							applyBaseMove(cube, "R");
							applyBaseMove(cube, "R");
							applyBaseMove(cube, "R");
							applyBaseMove(cube, "M");
						}
						continue;
					}
					if (move.face === "l") {
						if (direction === 1) {
							applyBaseMove(cube, "L");
							applyBaseMove(cube, "M");
						} else {
							applyBaseMove(cube, "L");
							applyBaseMove(cube, "L");
							applyBaseMove(cube, "L");
							applyBaseMove(cube, "M");
							applyBaseMove(cube, "M");
							applyBaseMove(cube, "M");
						}
						continue;
					}
					const face = move.face.toUpperCase();
					if (direction === 1) {
						applyBaseMove(cube, face);
					} else {
						applyBaseMove(cube, face);
						applyBaseMove(cube, face);
						applyBaseMove(cube, face);
					}
				}
			};

			const parseAlgorithm = (algorithm) => {
				return algorithm
					.split(/\s+/)
					.map((token) => token.trim())
					.filter(Boolean)
					.map((token) => {
						const match = token.match(/^([RULDFBrlM])([2]?)(['`]?)$/);
						if (!match) {
							throw new Error(`Invalid move: ${token}`);
						}
						return {
							face: match[1],
							isDouble: match[2] === "2",
							isPrime: match[3] === "'" || match[3] === "`",
							raw: token,
						};
					});
			};

			const invertMoves = (moves) => {
				return [...moves].reverse().map((move) => ({
					...move,
					isPrime: move.isDouble ? move.isPrime : !move.isPrime,
				}));
			};

			const buildCasePattern = (algorithm) => {
				const cube = createSolvedCube();
				const moves = parseAlgorithm(algorithm);
				const inverseMoves = invertMoves(moves);
				inverseMoves.forEach((move) => applyMove(cube, move));
				return cube;
			};

			const createMarker = (side, offset) => {
				const marker = document.createElement("span");
				marker.className = "oll-marker";
				marker.dataset.side = side;
				marker.style.setProperty("--offset", offset);
				return marker;
			};

			const createMiniCube = (cube) => {
				const cubeElement = document.createElement("div");
				cubeElement.className = "oll-cube";
				const edgeMarkers = [];
				const edgeMap = {
					1: { side: "top", offset: 1, face: "B", index: 1 },
					3: { side: "left", offset: 1, face: "L", index: 1 },
					5: { side: "right", offset: 1, face: "R", index: 1 },
					7: { side: "bottom", offset: 1, face: "F", index: 1 },
				};

				cube.U.forEach((color, index) => {
					const cell = document.createElement("div");
					cell.className = "oll-cell";
					if (color === "Y") {
						cell.classList.add("oll-cell--yellow");
					} else if (
						edgeMap[index] &&
						cube[edgeMap[index].face][edgeMap[index].index] === "Y"
					) {
						edgeMarkers.push(edgeMap[index]);
					}
					cubeElement.appendChild(cell);
				});

				edgeMarkers.forEach((marker) => {
					cubeElement.appendChild(createMarker(marker.side, marker.offset));
				});

				return cubeElement;
			};

			const ollTable = document.getElementById("ollTable");
			if (ollTable) {
				ollAlgorithms.forEach((ollCase) => {
					const link = document.createElement("a");
					link.href = `algs/alg.html?alg=${encodeURIComponent(ollCase.algorithm)}`;
					link.className = "ollCard";

					let cubeState;
					try {
						cubeState = buildCasePattern(ollCase.algorithm);
					} catch (error) {
						cubeState = createSolvedCube();
					}
					const cube = createMiniCube(cubeState);
					const info = document.createElement("div");
					info.className = "oll-details";
					info.innerHTML = `
						<h3>OLL ${ollCase.number} - ${ollCase.name}</h3>
						<p><strong>Group:</strong> ${ollCase.group}</p>
						<p><strong>Notation:</strong> OLL ${ollCase.number}</p>
						<p><strong>Algorithm:</strong> ${ollCase.algorithm}</p>
						<p>OLL ${ollCase.number} - <span class="oll-probability">probability = 1/54</span></p>
					`;

					link.appendChild(cube);
					link.appendChild(info);
					ollTable.appendChild(link);
				});
			}
		</script>
	</body>
</html>
