<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

		<title>Alg trainer Cube Coen Couwenberg</title>

		<!-- Babylon.js -->
		<script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

		<!-- Font Awesome -->
		<link
			rel="stylesheet"
			href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
			integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p"
			crossorigin="anonymous"
		/>

		<!-- fonts Open Sans-->
		<link rel="preconnect" href="https://fonts.gstatic.com" />
		<link
			href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&display=swap"
			rel="stylesheet"
		/>

		<!-- CSS bestand -->
		<link rel="stylesheet" href="assets/style.css" />
	</head>
	<body>
		<canvas id="renderCanvas"></canvas>
		<div class="section1">
			<div class="title">
				<div class="bannerTitle">
					<h1>Algorithm trainer</h1>
				</div>
				<div class="bannerSub">
					<p
						description='"3x3 Cube Solve" (https://skfb.ly/6zxJO) by Etherlyte is licensed under Creative Commons Attribution (http://creativecommons.org/licenses/by/4.0/).
					'
					>
						Click & hold to see around the cube
					</p>
				</div>
			</div>

			<div class="arrowDown">
				<a href="#algSection">
					<div class="downText">Down</div>
					<div class="icon">
						<i class="fas fa-sort-down"></i>
					</div>
				</a>
			</div>
		</div>

		<div class="section2" id="algSection">
			<div class="section2title">
				<a href="#renderCanvas">
					<i class="fas fa-caret-up"></i>
					<h2>Choose an algorithm</h2>
				</a>
			</div>
			<div class="chooseAlg">
				<div class="algorithms">
					<!-- 1 -->
					<a href="algs/alg.html?alg=R%20U%20R'%20U%20R%20U2%20R'">
						<div class="boxAlg">
							<img src="imgAlgs/1.png" alt="first alg" />
							<div class="algRight">
								<h2>R U R' U R U2 R'</h2>
								<p>
									OCLL7 - 27 - <span style="color: blue">probability = 1/54</span>
								</p>
							</div>
						</div>
					</a>
					<!-- 2 -->
					<a href="algs/alg2.html">
						<div class="boxAlg">
							<img src="imgAlgs/2.png" alt="Second alg" />
							<div class="algRight">
								<h2>R U2 R' U' R U' R'</h2>
								<p>
									OCLL7 - 26 - <span style="color: blue">probability = 1/54</span>
								</p>
							</div>
						</div>
					</a>
					<!-- 3 -->
					<a href="algs/alg3.html">
						<div class="boxAlg">
							<img src="imgAlgs/3.png" alt="third alg" />
							<div class="algRight">
								<h2>(R U R'U) (R U' R' U) (R U2 R')</h2>
								<p>
									OCLL7 - 21 -
									<span style="color: green">probability = 1/108</span>
								</p>
							</div>
						</div>
					</a>
					<!-- 4 -->
					<a href="algs/alg4.html">
					<div class="boxAlg" style="margin-right: -100px;">
						<img src="imgAlgs/4.png" alt="fourth alg" />
						<div class="algRight">
							<h2>R U2' R2 U' R2 U' R2' U2' R</h2>
							<p>OCLL2 - 22 - <span style="color: blue">probability = 1/54</span></p>
						</div>
					</div>
					</a>
					<a href="algs/algChatGPT.html">
					<div class="boxAlg">
						<img src="imgAlgs/1.png" alt="first alg" />
						<div class="algRight">
							<h2>New Version</h2>
							<p>OCLL7 - 27 - <span style="color: blue">probability = 1/54</span></p>
						</div>
					</div>
					</a>
					<div class="boxAlg">
						<img src="imgAlgs/1.png" alt="first alg" />
						<div class="algRight">
							<h2>R U R' U R U2 R'</h2>
							<p>OCLL7 - 27 - <span style="color: blue">probability = 1/54</span></p>
						</div>
					</div>
				</div>
			</div>
			<div class="ollOverview" id="ollOverview">
				<div class="section2title ollTitle">
					<h2>OLL algorithm overview</h2>
					<p>Choose any OLL case below to practice the full algorithm.</p>
				</div>
				<div class="ollTable" id="ollTable"></div>
			</div>

			<div class="help">
				<a href="help.html">
					<i class="far fa-question-circle"></i>
				</a>
			</div>
		</div>
		<div class="version-note">Version: v0.3.0</div>
		<script>
			var canvas = document.getElementById("renderCanvas");

			var engine = null;
			var scene = null;
			var sceneToRender = null;
			var createDefaultEngine = function () {
				return new BABYLON.Engine(canvas, true, {
					preserveDrawingBuffer: true,
					stencil: true,
					disableWebGL2Support: false,
				});
			};
			var delayCreateScene = function () {
				// Create a scene.
				var scene = new BABYLON.Scene(engine);
				var bannerCube;

				// Parameters: name, position, scene
				// var camera = new BABYLON.FollowCamera(
				// 	"FollowCam",
				// 	new BABYLON.Vector3(0, 10, -10),
				// 	scene
				// );
				// This creates and positions a free camera (non-mesh)
				// Parameters: name, alpha, beta, radius, target position, scene
				var camera = new BABYLON.ArcRotateCamera(
					"Camera",
					0,
					0,
					10,
					new BABYLON.Vector3(0, 0, 0),
					scene
				);
				// Positions the camera overwriting alpha, beta, radius
				camera.setPosition(new BABYLON.Vector3(0, 0, 20));
				// This attaches the camera to the canvas
				camera.attachControl(canvas, true);
				camera.wheelPrecision = 100; //Mouse wheel speed
				// camera.inputs.remove(camera.inputs.attached.mousewheel);

				// Create a default skybox with an environment.
				var hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
					"textures/environment2.dds",
					scene
				);
				var currentSkybox = scene.createDefaultSkybox(hdrTexture, true);

				// Append glTF model to scene.
				var bannerCube = BABYLON.SceneLoader.Append(
					"./",
					"scene.gltf",
					scene,
					function (scene) {
						// Create a default arc rotate camera and light.
						scene.createDefaultCameraOrLight(true, true, true);

						// The default camera looks at the back of the asset.
						// Rotate the camera by 180 degrees to the front of the asset.
						scene.activeCamera.alpha += Math.PI;
					}
				);

				// camera.rotation.x = +0.1;
				// "3x3 Cube Solve" (https://skfb.ly/6zxJO) by Etherlyte is licensed under Creative Commons Attribution (http://creativecommons.org/licenses/by/4.0/).

				return scene;
			};
			var engine;
			var scene;
			initFunction = async function () {
				var asyncEngineCreation = async function () {
					try {
						return createDefaultEngine();
					} catch (e) {
						console.log(
							"the available createEngine function failed. Creating the default engine instead"
						);
						return createDefaultEngine();
					}
				};

				engine = await asyncEngineCreation();
				if (!engine) throw "engine should not be null.";
				scene = delayCreateScene();
			};
			initFunction().then(() => {
				sceneToRender = scene;
				engine.runRenderLoop(function () {
					if (sceneToRender && sceneToRender.activeCamera) {
						sceneToRender.render();
					}
				});
			});

			// Resize
			window.addEventListener("resize", function () {
				engine.resize();
			});
		</script>
		<script>
			const ollGroups = [
				{
					name: "All Edges Oriented",
					cases: [
						{ number: 21, algorithm: "R U2 R' U' R U R' U' R U' R'" },
						{ number: 22, algorithm: "R U2 R2 U' R2 U' R2 U2 R" },
						{ number: 23, algorithm: "R2 D' R U2 R' D R U2 R" },
						{ number: 24, algorithm: "(r U R' U') (r' F R F')" },
						{ number: 25, algorithm: "(F' r U R' U') (r' F R)" },
						{ number: 26, algorithm: "R U2 R' U' R U' R'" },
						{ number: 27, algorithm: "R U R' U R U2 R'" },
					],
				},
				{
					name: "All Corners Oriented",
					cases: [
						{ number: 28, algorithm: "(r U R' U') (r' R U R U' R')" },
						{ number: 57, algorithm: "(R U R' U') (M' U R U' r')" },
					],
				},
				{
					name: "T Shapes",
					cases: [
						{ number: 33, algorithm: "(R U R' U') (R' F R F')" },
						{ number: 45, algorithm: "F (R U R' U') F'" },
					],
				},
				{
					name: "W Shapes",
					cases: [
						{ number: 36, algorithm: "L' U' L U' L' U L U L F' L' F" },
						{ number: 38, algorithm: "R U R' U R U' R' U' R' F R F'" },
						{ number: 35, algorithm: "R U2 (R2 F R F') U2 R'" },
						{ number: 37, algorithm: "(F R' F') (R U R U' R')" },
					],
				},
				{
					name: "Square Shapes",
					cases: [
						{ number: 5, algorithm: "l' U2 L U L' U l" },
						{ number: 6, algorithm: "r U2 R' U' R U' r'" },
					],
				},
				{
					name: "P Shapes",
					cases: [
						{ number: 31, algorithm: "R' U' F (U R U' R') F' R" },
						{ number: 32, algorithm: "L U F' (U' L' U L) F L'" },
						{ number: 43, algorithm: "R' U' F' U F R" },
						{ number: 44, algorithm: "F (U R U' R') F'" },
					],
				},
				{
					name: "Fish Shapes",
					cases: [
						{ number: 9, algorithm: "(R U R' U') R' F (R2 U R' U') F'" },
						{ number: 10, algorithm: "R U R' U R' F R F' R U2 R'" },
					],
				},
				{
					name: "C Shapes",
					cases: [
						{ number: 34, algorithm: "R U R2 U' R' F R U R U' F'" },
						{ number: 46, algorithm: "R' U' R' F R F' U R" },
					],
				},
				{
					name: "Small Lightning Bolts",
					cases: [
						{ number: 7, algorithm: "r U R' U R U2 r'" },
						{ number: 8, algorithm: "l' U' L U' L' U2 l" },
						{ number: 11, algorithm: "S' U2 R U R' U R U2 R' S" },
						{ number: 12, algorithm: "M' R' U' R U' R' U2 R U' R' r'" },
					],
				},
				{
					name: "Big Lightning Bolts",
					cases: [
						{ number: 39, algorithm: "(f' L F L') (U' L' U L) S" },
						{ number: 40, algorithm: "(f R' F' R) (U R U' R') S'" },
					],
				},
				{
					name: "Small L Shapes",
					cases: [
						{ number: 47, algorithm: "(F R' F') U2 R U' R' U R U2 R'" },
						{ number: 48, algorithm: "F (R U R' U') (R U R' U') F'" },
						{ number: 49, algorithm: "r U' r2 U r2 U r2 U' r" },
						{ number: 50, algorithm: "l' U l2 U' l2 U' l2 U l'" },
						{ number: 53, algorithm: "l' U2 L U L' U' L U L' U l" },
						{ number: 54, algorithm: "r U2 R' U' R U R' U' R U' r'" },
					],
				},
				{
					name: "Knight Move Shapes",
					cases: [
						{ number: 13, algorithm: "F (U R U' R2) F' R (U R U' R')" },
						{ number: 14, algorithm: "R' F R U R' F' R F U' F'" },
						{ number: 15, algorithm: "l' U' l (L' U' L U) l' U l" },
						{ number: 16, algorithm: "r U r' (R U R' U') r U' r'" },
					],
				},
				{
					name: "I Shapes",
					cases: [
						{ number: 51, algorithm: "F (U R U' R') (U R U' R') F'" },
						{ number: 52, algorithm: "R' F' U' F U R U' R' U R" },
						{ number: 55, algorithm: "R' F R U R U' R2 F' R2 U' R' U R U R'" },
						{ number: 56, algorithm: "r U r' U R U' R' U R U2 r'" },
					],
				},
				{
					name: "Cactus Shapes",
					cases: [
						{ number: 29, algorithm: "l D' l' D l D' l' D2 l" },
						{ number: 30, algorithm: "F R' F R2 U' R' U' R U R' F2" },
						{ number: 41, algorithm: "R U R' U R U2 R' F (R U R' U') F'" },
						{ number: 42, algorithm: "R' U' R U' R' U2 R F (R U R' U') F'" },
					],
				},
				{
					name: "No Edges Oriented",
					cases: [
						{ number: 1, algorithm: "R U2 (R2 F R F') U2 (R' F R F')" },
						{ number: 2, algorithm: "r U r' U2 r U2 R' U2 R U' r'" },
						{ number: 3, algorithm: "r' R2 U R' U r U2 r' U M'" },
						{ number: 4, algorithm: "M U' r U2 r' U' R U' R' M'" },
						{ number: 17, algorithm: "F R' F' R2 r' (U R U' R') U' M'" },
						{ number: 18, algorithm: "r U R' U R U2 r2 U' R U' R' U2 r" },
						{ number: 19, algorithm: "r' R (U R U R' U') M' (R' F R F')" },
						{ number: 20, algorithm: "(r U R' U') M2 (U R U' R') U' M'" },
					],
				},
			];

			const MOVE_CONFIGS = {
				R: { axis: "x", layers: [1], dir: -1 },
				L: { axis: "x", layers: [-1], dir: 1 },
				U: { axis: "y", layers: [1], dir: 1 },
				D: { axis: "y", layers: [-1], dir: -1 },
				F: { axis: "z", layers: [1], dir: -1 },
				B: { axis: "z", layers: [-1], dir: 1 },
				M: { axis: "x", layers: [0], dir: 1 },
				E: { axis: "y", layers: [0], dir: -1 },
				S: { axis: "z", layers: [0], dir: -1 },
				r: { axis: "x", layers: [1, 0], dir: -1 },
				l: { axis: "x", layers: [-1, 0], dir: 1 },
				u: { axis: "y", layers: [1, 0], dir: 1 },
				d: { axis: "y", layers: [-1, 0], dir: -1 },
				f: { axis: "z", layers: [1, 0], dir: -1 },
				b: { axis: "z", layers: [-1, 0], dir: 1 },
				x: { axis: "x", layers: [-1, 0, 1], dir: -1 },
				y: { axis: "y", layers: [-1, 0, 1], dir: 1 },
				z: { axis: "z", layers: [-1, 0, 1], dir: -1 },
			};

			const FACE_COLORS = {
				U: "Y",
				D: "W",
				F: "G",
				B: "B",
				R: "R",
				L: "O",
			};

			const FACE_NORMALS = {
				U: [0, 1, 0],
				D: [0, -1, 0],
				F: [0, 0, 1],
				B: [0, 0, -1],
				R: [1, 0, 0],
				L: [-1, 0, 0],
			};

			const normalToFace = (normal) => {
				const key = normal.join(",");
				const lookup = {
					"0,1,0": "U",
					"0,-1,0": "D",
					"0,0,1": "F",
					"0,0,-1": "B",
					"1,0,0": "R",
					"-1,0,0": "L",
				};
				return lookup[key];
			};

			const rotateVector = (vector, axis, dir) => {
				const [x, y, z] = vector;
				switch (axis) {
					case "x":
						return dir === 1 ? [x, -z, y] : [x, z, -y];
					case "y":
						return dir === 1 ? [z, y, -x] : [-z, y, x];
					case "z":
						return dir === 1 ? [-y, x, z] : [y, -x, z];
					default:
						return vector;
				}
			};

			const createSolvedCubies = () => {
				const cubies = [];
				for (let x = -1; x <= 1; x += 1) {
					for (let y = -1; y <= 1; y += 1) {
						for (let z = -1; z <= 1; z += 1) {
							const stickers = {};
							if (y === 1) stickers.U = FACE_COLORS.U;
							if (y === -1) stickers.D = FACE_COLORS.D;
							if (z === 1) stickers.F = FACE_COLORS.F;
							if (z === -1) stickers.B = FACE_COLORS.B;
							if (x === 1) stickers.R = FACE_COLORS.R;
							if (x === -1) stickers.L = FACE_COLORS.L;
							cubies.push({ x, y, z, stickers });
						}
					}
				}
				return cubies;
			};

			const rotateCubie = (cubie, axis, dir) => {
				[cubie.x, cubie.y, cubie.z] = rotateVector([cubie.x, cubie.y, cubie.z], axis, dir);
				const rotatedStickers = {};
				Object.entries(cubie.stickers).forEach(([face, color]) => {
					const normal = FACE_NORMALS[face];
					const rotatedNormal = rotateVector(normal, axis, dir);
					const rotatedFace = normalToFace(rotatedNormal);
					if (rotatedFace) {
						rotatedStickers[rotatedFace] = color;
					}
				});
				cubie.stickers = rotatedStickers;
			};

			const rotateLayers = (cubies, axis, layers, dir, turns) => {
				for (let turn = 0; turn < turns; turn += 1) {
					cubies.forEach((cubie) => {
						if (layers.includes(cubie[axis])) {
							rotateCubie(cubie, axis, dir);
						}
					});
				}
			};

			const normalizeAlgorithm = (algorithm) =>
				algorithm
					.replace(/[()\[\]]/g, " ")
					.replace(/,/g, " ")
					.replace(/\s+/g, " ")
					.trim();

			const parseAlgorithm = (algorithm) => {
				const normalized = normalizeAlgorithm(algorithm);
				if (!normalized) return [];
				return normalized.split(" ").map((token) => {
					const match = token.match(/^([RULDFBrludfbMESxyz])([2]?)(['`]?)$/);
					if (!match) {
						throw new Error(`Invalid move: ${token}`);
					}
					return {
						face: match[1],
						isDouble: match[2] === "2",
						isPrime: match[3] === "'" || match[3] === "`",
						raw: token,
					};
				});
			};

			const applyMove = (cubies, move) => {
				const config = MOVE_CONFIGS[move.face];
				if (!config) {
					throw new Error(`Invalid move: ${move.raw}`);
				}
				const turns = move.isDouble ? 2 : 1;
				const dir = config.dir * (move.isPrime ? -1 : 1);
				rotateLayers(cubies, config.axis, config.layers, dir, turns);
			};

			const invertMoves = (moves) =>
				[...moves].reverse().map((move) => ({
					...move,
					isPrime: move.isDouble ? move.isPrime : !move.isPrime,
				}));

			const findCubie = (cubies, x, y, z) =>
				cubies.find((cubie) => cubie.x === x && cubie.y === y && cubie.z === z);

			const U_INDEX_MAP = {
				"-1,-1": 0,
				"0,-1": 1,
				"1,-1": 2,
				"-1,0": 3,
				"0,0": 4,
				"1,0": 5,
				"-1,1": 6,
				"0,1": 7,
				"1,1": 8,
			};

			const getUFace = (cubies) => {
				const face = Array(9).fill("");
				cubies.forEach((cubie) => {
					if (cubie.y === 1 && cubie.stickers.U) {
						const index = U_INDEX_MAP[`${cubie.x},${cubie.z}`];
						face[index] = cubie.stickers.U;
					}
				});
				return face;
			};

			const getEdgeMarkers = (cubies) => {
				const edgeDefinitions = {
					top: { position: [0, 1, -1], face: "B" },
					left: { position: [-1, 1, 0], face: "L" },
					right: { position: [1, 1, 0], face: "R" },
					bottom: { position: [0, 1, 1], face: "F" },
				};
				return Object.entries(edgeDefinitions).reduce((markers, [side, definition]) => {
					const [x, y, z] = definition.position;
					const cubie = findCubie(cubies, x, y, z);
					if (!cubie) return markers;
					const uColor = cubie.stickers.U;
					const sideColor = cubie.stickers[definition.face];
					markers[side] = sideColor === FACE_COLORS.U && uColor !== FACE_COLORS.U;
					return markers;
				}, {});
			};

			const buildCasePattern = (algorithm) => {
				const cubies = createSolvedCubies();
				const moves = parseAlgorithm(algorithm);
				const inverseMoves = invertMoves(moves);
				inverseMoves.forEach((move) => applyMove(cubies, move));
				return {
					U: getUFace(cubies),
					markers: getEdgeMarkers(cubies),
				};
			};

			const createMarker = (side, offset) => {
				const marker = document.createElement("span");
				marker.className = "oll-marker";
				marker.dataset.side = side;
				marker.style.setProperty("--offset", offset);
				return marker;
			};

			const createMiniCube = (pattern) => {
				const cubeElement = document.createElement("div");
				cubeElement.className = "oll-cube";
				pattern.U.forEach((color) => {
					const cell = document.createElement("div");
					cell.className = "oll-cell";
					if (color === FACE_COLORS.U) {
						cell.classList.add("oll-cell--yellow");
					}
					cubeElement.appendChild(cell);
				});

				const markerOffsets = {
					top: 1,
					left: 1,
					right: 1,
					bottom: 1,
				};
				Object.entries(markerOffsets).forEach(([side, offset]) => {
					if (pattern.markers[side]) {
						cubeElement.appendChild(createMarker(side, offset));
					}
				});

				return cubeElement;
			};

			const createCaseRow = (ollCase, groupName) => {
				const link = document.createElement("a");
				link.href = `algs/alg.html?alg=${encodeURIComponent(ollCase.algorithm)}`;
				link.className = "oll-row";
				link.setAttribute("aria-label", `OLL ${ollCase.number} ${groupName}`);

				let pattern;
				try {
					pattern = buildCasePattern(ollCase.algorithm);
				} catch (error) {
					pattern = { U: Array(9).fill(FACE_COLORS.U), markers: {} };
				}

				const number = document.createElement("div");
				number.className = "oll-row__number";
				number.textContent = ollCase.number;

				const cube = createMiniCube(pattern);
				const info = document.createElement("div");
				info.className = "oll-row__info";
				info.innerHTML = `
					<div class="oll-row__title">OLL ${ollCase.number}</div>
					<div class="oll-row__algorithm">${ollCase.algorithm}</div>
					<div class="oll-row__meta">
						<span class="oll-row__notation">Notation: OLL ${ollCase.number}</span>
						<span class="oll-probability">probability = 1/54</span>
					</div>
				`;

				link.appendChild(number);
				link.appendChild(cube);
				link.appendChild(info);
				return link;
			};

			const ollTable = document.getElementById("ollTable");
			if (ollTable) {
				ollGroups.forEach((group) => {
					const section = document.createElement("section");
					section.className = "oll-group";

					const title = document.createElement("h3");
					title.className = "oll-group__title";
					title.textContent = group.name;
					section.appendChild(title);

					const cases = document.createElement("div");
					cases.className = "oll-group__cases";
					group.cases.forEach((ollCase) => {
						cases.appendChild(createCaseRow(ollCase, group.name));
					});

					section.appendChild(cases);
					ollTable.appendChild(section);
				});
			}
		</script>
	</body>
</html>
